<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Aeronautical Calculator â€“ Mach Â· CAS Â· Altitude</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg-main: #05070c;
            --bg-card: #0d141f;
            --bg-card-elevated: #111827;
            --bg-input: #111827;
            --bg-input-focus: #020617;
            --border-subtle: #1f2933;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.16);
            --accent-strong: #0ea5e9;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --danger: #f97373;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 16px;
            background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 60%, #000 100%);
            color: var(--text-main);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
            margin: 8px 0 4px;
            text-align: right;
            width: 100%;
            max-width: 960px;
        }

        .subtitle {
            width: 100%;
            max-width: 960px;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        /* ===== Card ===== */
        .card {
            width: 100%;
            max-width: 960px;
            background: radial-gradient(circle at top left, #111827 0, #020617 65%);
            border-radius: 18px;
            border: 1px solid #111827;
            box-shadow:
                0 18px 40px rgba(15, 23, 42, 0.8),
                0 0 0 1px rgba(15, 23, 42, 0.9);
            padding: 18px 20px 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .title-block {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .icon-circle {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            background: radial-gradient(circle at 20% 0, #38bdf8, #0f172a 70%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.4rem;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
        }

        .title-main {
            font-size: 1.15rem;
            font-weight: 600;
        }

        .title-sub {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .solve-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: left;
        }

        /* ===== Tabs ===== */
        .tabs {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 4px;
        }

        .tab {
            flex: 1;
            padding: 10px 8px 8px;
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
            background: #020617;
            color: var(--text-muted);
            font-size: 0.8rem;
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 3px;
            transition: background 0.15s, border-color 0.15s, color 0.15s, box-shadow 0.15s;
        }

        .tab span:first-child {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .tab span:last-child {
            font-size: 0.7rem;
            text-transform: lowercase;
        }

        .tab.active {
            border-color: var(--accent);
            background: radial-gradient(circle at top, #0b1120 0, #020617 55%);
            color: var(--text-main);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
        }

        /* ===== Form rows ===== */
        .form-rows {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 6px;
        }

        .form-row {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 260px;
            gap: 12px;
            align-items: center;
        }

        .form-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: left;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            direction: ltr; /* ×¡×“×¨ ××©×××œ ×œ×™××™×Ÿ ×‘×ª×•×š ×”×©×•×¨×” */
        }

        .field {
            width: 100px;
            padding: 7px 10px;
            border-radius: 10px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-input);
            color: var(--text-main);
            font-size: 0.9rem;
            outline: none;
            text-align: right;
            transition: border-color 0.15s, background 0.15s, box-shadow 0.15s;
        }

        .field:focus {
            border-color: var(--accent);
            background: var(--bg-input-focus);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
        }

        .field:disabled {
            opacity: 0.55;
            cursor: default;
        }

        .unit {
            font-size: 0.8rem;
            color: var(--text-muted);
            min-width: 30px;
            text-align: left;
        }

        /* spin buttons â€“ ××—×•×¥ ×œ×©×“×” */
        .spin-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .spin-buttons button {
            width: 28px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid #374151;
            background: #020617;
            color: #e5e7eb;
            font-size: 0.85rem;
            padding: 0;
            cursor: pointer;
        }

        .spin-buttons button:hover {
            border-color: #4b5563;
            background: #030712;
        }

        /* Buttons */
        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .primary-btn {
            border: none;
            border-radius: 999px;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            color: #020617;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 18px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow:
                0 12px 30px rgba(56, 189, 248, 0.5),
                0 0 0 1px rgba(15, 23, 42, 0.9);
        }

        .primary-btn span.icon {
            font-size: 1rem;
        }

        .reset-btn {
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            background: #020617;
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 6px 14px;
            cursor: pointer;
        }

        .helper-text {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .result-box {
            margin-top: 8px;
            font-size: 0.82rem;
            background: #020617;
            border-radius: 10px;
            padding: 6px 8px;
            border: 1px solid #111827;
            color: var(--text-main);
        }

        .result-box b {
            color: var(--accent-strong);
        }

        /* ===== Graph & slider ===== */
        #container {
            margin-top: 18px;
            width: 100%;
            max-width: 600px;
        }

        #machCanvas {
            border-radius: 10px;
            border: 1px solid #111827;
            background: #020617;
            width: 100%;
            height: auto;
            display: block;
        }

        #info {
            margin-top: 8px;
            font-size: 0.9rem;
            text-align: center;
            min-height: 1.2em;
        }

        #legend {
            margin-top: 4px;
            font-size: 0.8rem;
            opacity: 0.8;
            text-align: center;
        }

        #isaControl {
            margin-top: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #isaControl span {
            min-width: 40px;
            display: inline-block;
            text-align: left;
        }

        input[type="range"] {
            width: 220px;
        }

        @media (max-width: 720px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            .solve-label {
                text-align: left;
            }
        }
    </style>
</head>
<body>
    <h1>Aeronautical Calculator</h1>
    <div class="subtitle">CAS Â· Mach Â· Altitude â€“ ××—×©×‘×•×Ÿ ××•×•×™×¨×™ + ×’×¨×£ ××™× ×˜×¨××§×˜×™×‘×™</div>

    <div class="card">
        <div class="card-header">
            <div class="title-block">
                <div class="icon-circle">âœˆï¸</div>
                <div>
                    <div class="title-main">Aeronautical Calculator</div>
                    <div class="title-sub">CAS Â· Mach Â· Altitude Â· TAS Â· Î”ISA</div>
                </div>
            </div>
            <div class="solve-label">×‘×—×¨ ×¤×¨××˜×¨ ×œ×—×™×©×•×‘ (×—×•×¤×©×™):</div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab" id="tabCas">
                <span>CAS</span><span>knots</span>
            </button>
            <button class="tab" id="tabMach">
                <span>MACH</span><span>number</span>
            </button>
            <button class="tab active" id="tabAlt">
                <span>ALT</span><span>feet</span>
            </button>
        </div>

        <!-- Input rows -->
        <div class="form-rows">
            <div class="form-row">
                <div class="form-label">Calibrated Airspeed (CAS)</div>
                <div class="input-wrapper">
                    <!-- ××©×××œ: ×—×™×¦×™×, ×‘×××¦×¢: ×©×“×”, ×™××™× ×”: ×™×—×™×“×•×ª -->
                    <div class="spin-buttons" data-target="casInput" data-step="10" data-min="0" data-max="700">
                        <button type="button" class="spin-up">â–²</button>
                        <button type="button" class="spin-down">â–¼</button>
                    </div>
                    <input id="casInput" type="number" step="1" value="350" class="field">
                    <span class="unit">kts</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Mach Number</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="machInput" data-step="0.01" data-min="0" data-max="2">
                        <button type="button" class="spin-up">â–²</button>
                        <button type="button" class="spin-down">â–¼</button>
                    </div>
                    <input id="machInput" type="number" step="0.01" value="0.80" class="field">
                    <span class="unit">M</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Altitude</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="altInput" data-step="1000" data-min="0" data-max="50000">
                        <button type="button" class="spin-up">â–²</button>
                        <button type="button" class="spin-down">â–¼</button>
                    </div>
                    <input id="altInput" type="number" step="100" value="23000" class="field">
                    <span class="unit">ft</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Î”ISA (temperature deviation)</div>
                <div class="input-wrapper">
                    <!-- ××™×Ÿ ×—×™×¦×™×, ×¨×§ ×©×“×” + ×™×—×™×“×•×ª -->
                    <input id="isaInput" type="number" step="1" value="0" class="field">
                    <span class="unit">Â°C</span>
                </div>
            </div>
        </div>

        <div class="card-footer">
            <button id="solveButton" class="primary-btn">
                <span class="icon">ğŸ§®</span>
                <span>×—×™×©×•×‘ & ×”×¦×’×” ×¢×œ ×”×’×¨×£</span>
            </button>

            <button id="resetButton" class="reset-btn">Reset</button>

            <div class="helper-text">
                ×‘×¨×©×•×ª×š, ××—×©×‘ ×‘×œ×™ ××™×©×•×¨ ğŸ˜„
            </div>
        </div>

        <div id="calcResult" class="result-box">
            ×ª×•×¦××” ×ª×•×¦×’ ×›××Ÿâ€¦
        </div>
    </div>

    <!-- ×’×¨×£ -->
    <div id="container">
        <canvas id="machCanvas"></canvas>
    </div>
    <div id="info">×”×–×– ××ª ×”×¢×›×‘×¨ ××• ×”××¦×‘×¢ ××¢×œ ×”×’×¨×£, ×§×¨×•×‘ ×œ××—×“ ××§×•×•×™ ×”-Machâ€¦</div>
    <div id="legend">
        ×˜×•×•×—: CAS 150â€“700 ×§×©×¨, ×’×•×‘×” 0â€“40,000 ft. ×”×’×¨×£ ×ª××™×“ ××•×¦×’ ×‘×˜×•×•×— ×”××œ× ×œ×¨×•×—×‘, ××•×ª×× ×œ××¡×š ×¡×××¨×˜×¤×•×Ÿ.
    </div>
    <div id="isaControl">
        Î”ISA (Â°C):
        <span id="isaValue">0Â°C</span>
        <input type="range" id="isaSlider" min="-20" max="20" value="0">
    </div>

    <script>
        // ===== ISA constants =====
        const T0   = 288.15;
        const P0   = 101325.0;
        const R    = 287.05287;
        const G    = 9.80665;
        const L    = 0.0065;
        const GAMMA = 1.4;
        const FT_PER_M = 3.28084;

        const CAS_MIN = 150;
        const CAS_MAX = 700;
        const ALT_MIN = 0;
        const ALT_MAX = 40000;

        const machValues = [];
        for (let m = 0.6; m <= 1.2001; m += 0.1) {
            machValues.push(parseFloat(m.toFixed(1)));
        }

        const altStepFt = 2000;

        const canvas = document.getElementById('machCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const isaSlider = document.getElementById('isaSlider');
        const isaValueSpan = document.getElementById('isaValue');

        const marginLeft = 70;
        const marginRight = 25;
        const marginTop = 40;
        const marginBottom = 50;

        let machLinesData = [];
        let lockedPoint = null;
        let currentPoint = null;
        let highlightCasTick = null;
        let highlightAltTick = null;
        let isaDeviationC = 0;
        let lastTouchPos = null;

        // ×˜×•×•×— CAS ××•×¦×’ â€“ ×¢×›×©×™×• ×§×‘×•×¢ ×¢×œ ×˜×•×•×— ××œ×
        let viewCasMin = CAS_MIN;
        let viewCasMax = CAS_MAX;

        let calcMode = "solveAlt";

        // ===== ISA & CAS/Mach helpers =====
        function isaAtAltitude(hMeters) {
            let T, p;
            if (hMeters <= 11000.0) {
                T = T0 - L * hMeters;
                p = P0 * Math.pow(T / T0, G / (R * L));
            } else {
                const T11 = T0 - L * 11000.0;
                const p11 = P0 * Math.pow(T11 / T0, G / (R * L));
                T = T11;
                p = p11 * Math.exp(-G * (hMeters - 11000.0) / (R * T));
            }
            const rho = p / (R * T);
            const a = Math.sqrt(GAMMA * R * T);
            return { T, p, rho, a };
        }

        function casFromMachAndAlt(M, hMeters) {
            const atm = isaAtAltitude(hMeters);
            const p = atm.p;
            const qc = p * (Math.pow(1 + 0.2 * M * M, 3.5) - 1.0);
            const a0 = Math.sqrt(GAMMA * R * T0);
            const ptOverP0 = qc / P0 + 1.0;
            const Vc2 = 5 * a0 * a0 * (Math.pow(ptOverP0, 2.0 / 7.0) - 1.0);
            const Vc2pos = Math.max(Vc2, 0);
            const Vc = Math.sqrt(Vc2pos);
            return Vc / 0.514444;
        }

        function tasFromPoint(point) {
            if (!point) return null;
            const altM = point.altFt / FT_PER_M;
            const atmISA = isaAtAltitude(altM);
            const T_actual = atmISA.T + isaDeviationC;
            const a_actual = Math.sqrt(GAMMA * R * T_actual);
            const tas_ms = point.M * a_actual;
            const tas_kt = tas_ms / 0.514444;
            return tas_kt;
        }

        function findAltitudeForCasAndMach(M, casTarget) {
            const hMin = ALT_MIN / FT_PER_M;
            const hMax = ALT_MAX / FT_PER_M;

            function f(h) {
                return casFromMachAndAlt(M, h) - casTarget;
            }

            let fMin = f(hMin);
            let fMax = f(hMax);
            if (!isFinite(fMin) || !isFinite(fMax) || fMin * fMax > 0) {
                return null;
            }

            let lo = hMin;
            let hi = hMax;
            for (let i = 0; i < 50; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fMin * fMid <= 0) {
                    hi = mid;
                    fMax = fMid;
                } else {
                    lo = mid;
                    fMin = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        function solveMachGivenCasAlt(casTarget, altFt) {
            const altM = altFt / FT_PER_M;
            function f(M) {
                return casFromMachAndAlt(M, altM) - casTarget;
            }

            let lo = 0.1;
            let hi = 2.0;
            let fLo = f(lo);
            let fHi = f(hi);

            if (!isFinite(fLo) || !isFinite(fHi) || fLo * fHi > 0) {
                return null;
            }

            for (let i = 0; i < 60; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fLo * fMid <= 0) {
                    hi = mid;
                    fHi = fMid;
                } else {
                    lo = mid;
                    fLo = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        // ===== Mapping (×¢× viewCasMin/Max ×§×‘×•×¢×™×) =====
        function xFromCas(cas) {
            const frac = (cas - viewCasMin) / (viewCasMax - viewCasMin);
            return marginLeft + frac * (canvas.width - marginLeft - marginRight);
        }

        function yFromAlt(altFt) {
            const frac = (altFt - ALT_MIN) / (ALT_MAX - ALT_MIN);
            return canvas.height - marginBottom - frac * (canvas.height - marginTop - marginBottom);
        }

        function casFromX(x) {
            const frac = (x - marginLeft) / (canvas.width - marginLeft - marginRight);
            return viewCasMin + frac * (viewCasMax - viewCasMin);
        }

        function altFromY(y) {
            const frac = (canvas.height - marginBottom - y) / (canvas.height - marginTop - marginBottom);
            return ALT_MIN + frac * (ALT_MAX - ALT_MIN);
        }

        function buildMachLineData(M) {
            const pts = [];
            for (let altFt = ALT_MIN; altFt <= ALT_MAX + 1; altFt += altStepFt) {
                const altM = altFt / FT_PER_M;
                const cas = casFromMachAndAlt(M, altM);
                pts.push({ cas, altFt });
            }
            return { M, pts };
        }

        function buildData() {
            machLinesData = [];
            for (const M of machValues) {
                machLinesData.push(buildMachLineData(M));
            }
        }

        function addMachLineIfMissing(M) {
            const mNum = Number(M);
            if (!isFinite(mNum)) return;
            const eps = 1e-6;
            for (const line of machLinesData) {
                if (Math.abs(line.M - mNum) < eps) return;
            }
            machLinesData.push(buildMachLineData(mNum));
        }

        function drawAxesAndGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#020617";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // grid vertical
            ctx.strokeStyle = "#1f2937";
            ctx.lineWidth = 0.9;
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                if (cas < viewCasMin || cas > viewCasMax) continue;
                const x = xFromCas(cas);
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
            }
            ctx.stroke();

            // grid horizontal
            ctx.beginPath();
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // axes
            ctx.strokeStyle = "#9ca3af";
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMax), yFromAlt(ALT_MIN));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMin), yFromAlt(ALT_MAX));
            ctx.stroke();

            // X ticks
            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const yAxis = yFromAlt(ALT_MIN);
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 10) {
                if (cas < viewCasMin || cas > viewCasMax) continue;
                const x = xFromCas(cas);
                const tickLen = (cas % 50 === 0) ? 6 : 3;
                ctx.moveTo(x, yAxis);
                ctx.lineTo(x, yAxis + tickLen);
            }
            ctx.stroke();

            ctx.font = "11px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                if (cas < viewCasMin || cas > viewCasMax) continue;
                const x = xFromCas(cas);
                const yAxisLocal = yFromAlt(ALT_MIN);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(x, yAxisLocal);
                ctx.lineTo(x, yAxisLocal + 6);
                ctx.stroke();

                if (highlightCasTick !== null && cas === highlightCasTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(cas.toString(), x, yAxisLocal + 8);
            }

            // Y ticks
            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const xAxis = xFromCas(viewCasMin);
            for (let alt = 0; alt <= 40000; alt += 1000) {
                const y = yFromAlt(alt);
                const tickLen = (alt % 5000 === 0) ? 6 : 3;
                ctx.moveTo(xAxis - tickLen, y);
                ctx.lineTo(xAxis, y);
            }
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                const xAxisLocal = xFromCas(viewCasMin);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(xAxisLocal - 6, y);
                ctx.lineTo(xAxisLocal, y);
                ctx.stroke();

                if (highlightAltTick !== null && alt === highlightAltTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(alt.toString(), xAxisLocal - 8, y);
            }

            ctx.fillStyle = "#e5e7eb";
            ctx.font = "13px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("CAS [kt]", (xFromCas(viewCasMin) + xFromCas(viewCasMax)) / 2, canvas.height - marginBottom + 20);

            ctx.save();
            ctx.translate(20, (yFromAlt(ALT_MIN) + yFromAlt(ALT_MAX)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("Altitude [ft]", 0, 0);
            ctx.restore();

            ctx.font = "16px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("Machâ€“CASâ€“Altitude Chart", canvas.width / 2, 8);
        }

        function drawMachLines(highlightMach) {
            const colors = ["#4FC3F7","#29B6F6","#03A9F4","#0288D1","#0277BD","#0ea5e9","#81D4FA"];
            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const pts = line.pts;
                const color = colors[i % colors.length];

                ctx.beginPath();
                let started = false;
                for (let j = 0; j < pts.length; j++) {
                    const cas = pts[j].cas;
                    if (cas < viewCasMin || cas > viewCasMax) continue;
                    const x = xFromCas(cas);
                    const y = yFromAlt(pts[j].altFt);
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                if (!started) continue;

                if (highlightMach != null && Math.abs(line.M - highlightMach) < 1e-6) {
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 2.0;
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.4;
                }
                ctx.stroke();
            }

            const labelAltFt = 36000;
            ctx.font = "11px system-ui";
            ctx.fillStyle = "#bfdbfe";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";

            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const casLabel = casFromMachAndAlt(line.M, labelAltFt / FT_PER_M);
                if (casLabel < viewCasMin || casLabel > viewCasMax) continue;
                const xLabel = xFromCas(casLabel);
                const yLabel = yFromAlt(labelAltFt) - 8;

                ctx.save();
                ctx.translate(xLabel, yLabel);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(line.M.toFixed(2) + "M", 0, 0);
                ctx.restore();
            }
        }

        function drawPointLabel(point) {
            if (!point) return;

            const M   = Number(point.M);
            const cas = Number(point.cas);
            const alt = Number(point.altFt);
            if (!isFinite(M) || !isFinite(cas) || !isFinite(alt)) return;

            const x = xFromCas(cas);
            const y = yFromAlt(alt);

            const tas = tasFromPoint({ M: M, altFt: alt });
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";

            const text = `${M.toFixed(2)}M | ${cas.toFixed(1)} kt CAS | ${alt.toFixed(0)} ft | ${tasStr} kt TAS | ISA${deltaStr}`;

            ctx.font = "12px system-ui";
            const paddingX = 7;
            const paddingY = 5;
            const textWidth = ctx.measureText(text).width;

            let boxX = x + 10;
            let boxY = y - 12;

            if (boxX + textWidth + 2 * paddingX > canvas.width - marginRight) {
                boxX = x - 10 - (textWidth + 2 * paddingX);
            }

            ctx.fillStyle = "rgba(15,23,42,0.95)";
            ctx.strokeStyle = "#38bdf8";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(boxX, boxY - paddingY, textWidth + 2 * paddingX, 2 * paddingY + 14);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#E1F5FE";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText(text, boxX + paddingX, boxY - paddingY + 3);
        }

        function redraw(point) {
            currentPoint = point || null;
            drawAxesAndGrid();
            drawMachLines(point ? point.M : (lockedPoint ? lockedPoint.M : null));

            const p = point || lockedPoint;
            if (p) {
                const x = xFromCas(p.cas);
                const y = yFromAlt(p.altFt);

                ctx.strokeStyle = "#6b7280";
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = lockedPoint ? "#f97373" : "#facc15";
                ctx.beginPath();
                ctx.arc(x, y, 4.5, 0, 2 * Math.PI);
                ctx.fill();

                drawPointLabel(p);
            }
        }

        function findNearestOnLines(mx, my) {
            const thresholdPx = 12;

            let bestLine = null;
            let bestDist = Infinity;
            for (const line of machLinesData) {
                for (const pt of line.pts) {
                    const cas = pt.cas;
                    if (cas < viewCasMin || cas > viewCasMax) continue;
                    const px = xFromCas(cas);
                    const py = yFromAlt(pt.altFt);
                    const dx = px - mx;
                    const dy = py - my;
                    const d2 = dx*dx + dy*dy;
                    if (d2 < bestDist) {
                        bestDist = d2;
                        bestLine = line;
                    }
                }
            }

            if (!bestLine || Math.sqrt(bestDist) > thresholdPx) return null;

            let rawCas = casFromX(mx);
            let snappedCas = Math.round(rawCas / 10) * 10;
            if (snappedCas < CAS_MIN) snappedCas = CAS_MIN;
            if (snappedCas > CAS_MAX) snappedCas = CAS_MAX;

            const hM = findAltitudeForCasAndMach(bestLine.M, snappedCas);
            if (hM === null) return null;
            const altFt = hM * FT_PER_M;

            return { M: bestLine.M, cas: snappedCas, altFt: altFt };
        }

        function handlePointerMove(mx, my) {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
                infoDiv.textContent =
                    `LOCKED â†’ Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
                return;
            }

            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "×”×–×– ××ª ×”×¢×›×‘×¨ ××• ×”××¦×‘×¢ ××¢×œ ×”×’×¨×£, ×§×¨×•×‘ ×œ××—×“ ××§×•×•×™ ×”-Machâ€¦";
                return;
            }

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                highlightCasTick = Math.round(nearest.cas / 50) * 50;
                highlightAltTick = Math.round(nearest.altFt / 5000) * 5000;
                redraw(nearest);
                const tas = tasFromPoint(nearest);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
                infoDiv.textContent =
                    `Mach ${nearest.M.toFixed(2)} | CAS ${nearest.cas.toFixed(1)} kt | Alt ${nearest.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                const casApprox = casFromX(mx).toFixed(0);
                const altApprox = altFromY(my).toFixed(0);
                infoDiv.textContent =
                    `×œ× ×¢×œ ×§×• Mach. ×‘×¢×¨×š: CAS â‰ˆ ${casApprox} kt, Alt â‰ˆ ${altApprox} ft`;
            }
        }

        function handlePointerClick(mx, my) {
            if (lockedPoint) {
                lockedPoint = null;
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "× ×¢×™×œ×” ×‘×•×˜×œ×”. ×”×–×– ××ª ×”×¢×›×‘×¨ ××• ×”××¦×‘×¢ ××¢×œ ×”×’×¨×£â€¦";
                return;
            }

            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) return;

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                lockedPoint = nearest;
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
                infoDiv.textContent =
                    `LOCKED â†’ Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerMove(mx, my);
        });

        canvas.addEventListener('mouseleave', () => {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
                infoDiv.textContent =
                    `LOCKED â†’ Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "×”×–×– ××ª ×”×¢×›×‘×¨ ××• ×”××¦×‘×¢ ××¢×œ ×”×’×¨×£, ×§×¨×•×‘ ×œ××—×“ ××§×•×•×™ ×”-Machâ€¦";
            }
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerClick(mx, my);
        });

        canvas.addEventListener('touchstart', (e) => {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;
            lastTouchPos = { x: mx, y: my };
            handlePointerMove(mx, my);
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;
            lastTouchPos = { x: mx, y: my };
            handlePointerMove(mx, my);
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            if (lastTouchPos) {
                handlePointerClick(lastTouchPos.x, lastTouchPos.y);
                lastTouchPos = null;
            }
        });

        // API
        window.highlightMachCasAlt = function(M, cas, altFt) {
            const mNum   = Number(M);
            const casNum = Number(cas);

            if (!isFinite(mNum) || !isFinite(casNum)) {
                console.warn("highlightMachCasAlt: Mach ××• CAS ×œ× ××¡×¤×¨×™× ×ª×§×™× ×™×", M, cas);
                return;
            }

            addMachLineIfMissing(mNum);

            let useAltFt = altFt;
            if (!isFinite(useAltFt)) {
                const hM = findAltitudeForCasAndMach(mNum, casNum);
                if (hM === null) {
                    console.warn("highlightMachCasAlt: ×œ× × ××¦× ×’×•×‘×” ×¢×‘×•×¨ ×”×©×™×œ×•×‘ ×”×–×” (Mach/CAS)", mNum, casNum);
                    return;
                }
                useAltFt = hM * FT_PER_M;
            }

            const altNum = Number(useAltFt);
            if (!isFinite(altNum)) {
                console.warn("highlightMachCasAlt: Altitude ×œ× ×ª×§×™×Ÿ", useAltFt);
                return;
            }

            lockedPoint = { M: mNum, cas: casNum, altFt: altNum };
            highlightCasTick = Math.round(casNum / 50) * 50;
            highlightAltTick = Math.round(altNum / 5000) * 5000;
            redraw(lockedPoint);

            const tas = tasFromPoint(lockedPoint);
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
            infoDiv.textContent =
                `LOCKED (API) â†’ Mach ${mNum.toFixed(2)} | CAS ${casNum.toFixed(1)} kt | Alt ${altNum.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
        };

        // ×—×™×©×•×‘ ××ª×•×š ×”×¤×× ×œ
        function runAeroCalcFromPanel() {
            let M   = parseFloat(document.getElementById('machInput').value);
            let cas = parseFloat(document.getElementById('casInput').value);
            let alt = parseFloat(document.getElementById('altInput').value);
            let dIsa = parseFloat(document.getElementById('isaInput').value);

            if (isNaN(dIsa)) dIsa = 0;
            isaDeviationC = dIsa;
            const sign = dIsa > 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${dIsa.toFixed(0)}Â°C`;

            let solvedM = M;
            let solvedCas = cas;
            let solvedAlt = alt;

            if (calcMode === "solveMach") {
                if (!isFinite(cas) || !isFinite(alt)) {
                    alert("×‘××¦×‘ 'MACH' ×—×™×™×‘×™× ×œ×”×–×™×Ÿ CAS ×•-Alt");
                    return;
                }
                const mRes = solveMachGivenCasAlt(cas, alt);
                if (mRes === null) {
                    alert("×œ× × ××¦× ×¤×ª×¨×•×Ÿ Mach ×¢×‘×•×¨ ×”×©×™×œ×•×‘ ×”×–×”");
                    return;
                }
                solvedM = mRes;
                solvedCas = cas;
                solvedAlt = alt;
                document.getElementById('machInput').value = solvedM.toFixed(3);
            } else if (calcMode === "solveCas") {
                if (!isFinite(M) || !isFinite(alt)) {
                    alert("×‘××¦×‘ 'CAS' ×—×™×™×‘×™× ×œ×”×–×™×Ÿ Mach ×•-Alt");
                    return;
                }
                const altM = alt / FT_PER_M;
                const casRes = casFromMachAndAlt(M, altM);
                solvedM = M;
                solvedCas = casRes;
                solvedAlt = alt;
                document.getElementById('casInput').value = solvedCas.toFixed(1);
            } else if (calcMode === "solveAlt") {
                if (!isFinite(M) || !isFinite(cas)) {
                    alert("×‘××¦×‘ 'ALT' ×—×™×™×‘×™× ×œ×”×–×™×Ÿ Mach ×•-CAS");
                    return;
                }
                const hM = findAltitudeForCasAndMach(M, cas);
                if (hM === null) {
                    alert("×œ× × ××¦× ×’×•×‘×” ×¢×‘×•×¨ ×”×©×™×œ×•×‘ ×”×–×”");
                    return;
                }
                solvedM = M;
                solvedCas = cas;
                solvedAlt = hM * FT_PER_M;
                document.getElementById('altInput').value = solvedAlt.toFixed(0);
            }

            if (!isFinite(solvedM) || !isFinite(solvedCas) || !isFinite(solvedAlt)) {
                alert("×©×™×œ×•×‘ ×ª×•×¦××” ×œ× ×ª×§×™×Ÿ");
                return;
            }

            const pointForTas = { M: solvedM, altFt: solvedAlt };
            const tasVal = tasFromPoint(pointForTas);
            const tasStr = tasVal ? tasVal.toFixed(1) : "N/A";
            const dIsaStr = (dIsa > 0 ? "+" : "") + dIsa.toFixed(0) + "Â°C";

            const resDiv = document.getElementById('calcResult');
            resDiv.innerHTML =
                `Mach: <b>${solvedM.toFixed(3)}</b> | ` +
                `CAS: <b>${solvedCas.toFixed(1)} kt</b> | ` +
                `Alt: <b>${solvedAlt.toFixed(0)} ft</b> | ` +
                `TAS: <b>${tasStr} kt</b> | ` +
                `ISA: <b>${dIsaStr}</b>`;

            addMachLineIfMissing(solvedM);
            window.highlightMachCasAlt(solvedM, solvedCas, solvedAlt);
        }

        function setCalcMode(mode) {
            calcMode = mode;

            const tabCas  = document.getElementById('tabCas');
            const tabMach = document.getElementById('tabMach');
            const tabAlt  = document.getElementById('tabAlt');

            tabCas.classList.remove('active');
            tabMach.classList.remove('active');
            tabAlt.classList.remove('active');

            const casInput  = document.getElementById('casInput');
            const machInput = document.getElementById('machInput');
            const altInput  = document.getElementById('altInput');

            casInput.disabled  = false;
            machInput.disabled = false;
            altInput.disabled  = false;

            if (mode === "solveCas") {
                tabCas.classList.add('active');
                casInput.disabled = true;
            } else if (mode === "solveMach") {
                tabMach.classList.add('active');
                machInput.disabled = true;
            } else {
                tabAlt.classList.add('active');
                altInput.disabled = true;
            }
        }

        function resetAll() {
            document.getElementById('casInput').value = 350;
            document.getElementById('machInput').value = 0.80;
            document.getElementById('altInput').value = 23000;
            document.getElementById('isaInput').value = 0;
            isaDeviationC = 0;
            isaSlider.value = 0;
            isaValueSpan.textContent = "0Â°C";
            lockedPoint = null;
            currentPoint = null;
            highlightCasTick = null;
            highlightAltTick = null;
            document.getElementById('calcResult').textContent = "×ª×•×¦××” ×ª×•×¦×’ ×›××Ÿâ€¦";
            redraw(null);
            infoDiv.textContent = "×”×–×– ××ª ×”×¢×›×‘×¨ ××• ×”××¦×‘×¢ ××¢×œ ×”×’×¨×£, ×§×¨×•×‘ ×œ××—×“ ××§×•×•×™ ×”-Machâ€¦";
            setCalcMode("solveAlt");
        }

        // ×”×ª×××ª ×§× ×‘×¡ â€“ ×ª××™×“ ×œ××•×¨×š
        function resizeCanvas() {
            const container = document.getElementById('container');
            const maxWidth = 600;
            const deviceWidth = container.clientWidth || window.innerWidth - 32;
            const width = Math.min(maxWidth, deviceWidth);
            const height = width * 1.2;
            canvas.width = width;
            canvas.height = height;
            redraw(currentPoint || lockedPoint || null);
        }

        window.addEventListener('resize', resizeCanvas);

        // spin buttons
        function attachSpinButtons() {
            document.querySelectorAll('.spin-buttons').forEach(spin => {
                const targetId = spin.dataset.target;
                const step = parseFloat(spin.dataset.step) || 1;
                const min = spin.dataset.min !== undefined ? parseFloat(spin.dataset.min) : null;
                const max = spin.dataset.max !== undefined ? parseFloat(spin.dataset.max) : null;
                const input = document.getElementById(targetId);
                if (!input) return;

                function adjust(sign) {
                    let v = parseFloat(input.value);
                    if (isNaN(v)) v = 0;
                    v += sign * step;
                    if (min !== null && v < min) v = min;
                    if (max !== null && v > max) v = max;

                    if (step >= 1) input.value = v.toFixed(0);
                    else input.value = v.toFixed(2);
                }

                const up = spin.querySelector('.spin-up');
                const down = spin.querySelector('.spin-down');
                if (up)   up.addEventListener('click', () => adjust(+1));
                if (down) down.addEventListener('click', () => adjust(-1));
            });
        }

        isaSlider.addEventListener('input', () => {
            isaDeviationC = parseInt(isaSlider.value, 10) || 0;
            const sign = isaDeviationC > 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${isaDeviationC}Â°C`;

            if (currentPoint || lockedPoint) {
                redraw(currentPoint || lockedPoint);
                const p = lockedPoint || currentPoint;
                const tas = tasFromPoint(p);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC > 0 ? "+" : "") + isaDeviationC.toFixed(0) + "Â°C";
                infoDiv.textContent =
                    `${lockedPoint ? "LOCKED â†’ " : ""}Mach ${p.M.toFixed(2)} | CAS ${p.cas.toFixed(1)} kt | Alt ${p.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                redraw(null);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('solveButton').addEventListener('click', runAeroCalcFromPanel);
            document.getElementById('resetButton').addEventListener('click', resetAll);

            document.getElementById('tabCas').addEventListener('click', () => setCalcMode("solveCas"));
            document.getElementById('tabMach').addEventListener('click', () => setCalcMode("solveMach"));
            document.getElementById('tabAlt').addEventListener('click', () => setCalcMode("solveAlt"));

            setCalcMode("solveAlt");
            attachSpinButtons();
            resizeCanvas();
        });

        buildData();
    </script>
</body>
</html>
