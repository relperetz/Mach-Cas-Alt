<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Aeronautical Calculator ‚Äì Mach ¬∑ CAS ¬∑ Altitude</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg-main: #05070c;
            --bg-card: #0d141f;
            --bg-card-elevated: #111827;
            --bg-input: #111827;
            --bg-input-focus: #020617;
            --border-subtle: #1f2933;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.16);
            --accent-strong: #0ea5e9;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --danger: #f97373;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 16px;
            background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 60%, #000 100%);
            color: var(--text-main);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
            margin: 8px 0 4px;
            text-align: left;
            width: 100%;
            max-width: 960px;
        }

        .subtitle {
            width: 100%;
            max-width: 960px;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 10px;
            text-align: left;
        }

        /* ===== Card ===== */
        .card {
            width: 100%;
            max-width: 960px;
            background: radial-gradient(circle at top left, #111827 0, #020617 65%);
            border-radius: 18px;
            border: 1px solid #111827;
            box-shadow:
                0 18px 40px rgba(15, 23, 42, 0.8),
                0 0 0 1px rgba(15, 23, 42, 0.9);
            padding: 18px 20px 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .title-block {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .icon-circle {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            background: radial-gradient(circle at 20% 0, #38bdf8, #0f172a 70%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.4rem;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
        }

        .title-main {
            font-size: 1.15rem;
            font-weight: 600;
        }

        .title-sub {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .solve-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: right;
        }

        /* ===== Tabs ===== */
        .tabs {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 4px;
        }

        .tab {
            flex: 1;
            padding: 10px 8px 8px;
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
            background: #020617;
            color: var(--text-muted);
            font-size: 0.8rem;
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 3px;
            transition: background 0.15s, border-color 0.15s, color 0.15s, box-shadow 0.15s;
        }

        .tab span:first-child {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .tab span:last-child {
            font-size: 0.7rem;
            text-transform: lowercase;
        }

        .tab.active {
            border-color: var(--accent);
            background: radial-gradient(circle at top, #0b1120 0, #020617 55%);
            color: var(--text-main);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
        }

        /* ===== Form rows ===== */
        .form-rows {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 6px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 260px minmax(0, 1fr);
            gap: 12px;
            align-items: center;
        }

        .form-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: left;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
        }

        .field {
            width: 110px;
            padding: 7px 10px;
            border-radius: 10px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-input);
            color: var(--text-main);
            font-size: 0.9rem;
            outline: none;
            text-align: right;
            transition: border-color 0.15s, background 0.15s, box-shadow 0.15s;
        }

        .field:focus {
            border-color: var(--accent);
            background: var(--bg-input-focus);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
        }

        .field:disabled {
            opacity: 0.55;
            cursor: default;
        }

        .unit {
            font-size: 0.8rem;
            color: var(--text-muted);
            min-width: 30px;
            text-align: left;
        }

        /* spin buttons ‚Äì outside input */
        .spin-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .spin-buttons button {
            width: 28px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid #374151;
            background: #020617;
            color: #e5e7eb;
            font-size: 0.85rem;
            padding: 0;
            cursor: pointer;
        }

        .spin-buttons button:hover {
            border-color: #4b5563;
            background: #030712;
        }

        /* Buttons */
        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .primary-btn {
            border: none;
            border-radius: 999px;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            color: #020617;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 18px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow:
                0 12px 30px rgba(56, 189, 248, 0.5),
                0 0 0 1px rgba(15, 23, 42, 0.9);
        }

        .primary-btn span.icon {
            font-size: 1rem;
        }

        .reset-btn {
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            background: #020617;
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 6px 14px;
            cursor: pointer;
        }

        .helper-text {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .result-box {
            margin-top: 8px;
            font-size: 0.82rem;
            background: #020617;
            border-radius: 10px;
            padding: 6px 8px;
            border: 1px solid #111827;
            color: var(--text-main);
        }

        .result-box b {
            color: var(--accent-strong);
        }

        /* ===== Graph & slider ===== */
        #container {
            margin-top: 18px;
            width: 100%;
            max-width: 600px;
        }

        #machCanvas {
            border-radius: 10px;
            border: 1px solid #111827;
            background: #020617;
            width: 100%;
            height: auto;
            display: block;
        }

        #info {
            margin-top: 8px;
            font-size: 0.9rem;
            text-align: center;
            min-height: 1.2em;
        }

        #legend {
            margin-top: 4px;
            font-size: 0.8rem;
            opacity: 0.8;
            text-align: center;
        }

        #isaControl {
            margin-top: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #isaControl span {
            min-width: 40px;
            display: inline-block;
            text-align: left;
        }

        input[type="range"] {
            width: 220px;
        }

        @media (max-width: 720px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            .solve-label {
                text-align: right;
            }
        }
    </style>
</head>
<body>
    <!-- <h1>Aeronautical Calculator</h1>
    <div class="subtitle">CAS ¬∑ Mach ¬∑ Altitude ‚Äì ◊û◊ó◊©◊ë◊ï◊ü ◊ê◊ï◊ï◊ô◊®◊ô + ◊í◊®◊£ ◊ê◊ô◊†◊ò◊®◊ê◊ß◊ò◊ô◊ë◊ô</div> -->

    <div class="card">
        <div class="card-header">
            <div class="title-block">
                <div class="icon-circle">‚úàÔ∏è</div>
                <div>
                    <div class="title-main">Aeronautical Calculator</div>
                    <div class="title-sub">CAS ¬∑ Mach ¬∑ Altitude</div>
                </div>
            </div>
            <div class="solve-label">◊ë◊ó◊® ◊§◊®◊û◊ò◊® ◊ú◊ó◊ô◊©◊ï◊ë, ◊§◊®◊ô◊†◊¶◊ô:</div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab" id="tabCas">
                <span>CAS</span><span>knots</span>
            </button>
            <button class="tab" id="tabMach">
                <span>MACH</span><span>number</span>
            </button>
            <button class="tab active" id="tabAlt">
                <span>ALT</span><span>feet</span>
            </button>
        </div>

        <!-- Input rows -->
        <div class="form-rows">
            <div class="form-row">
                <div class="form-label">Calibrated Airspeed (CAS):</div>
                <div class="input-wrapper">
                    <!-- left: arrows, middle: input, right: unit -->
                    <div class="spin-buttons" data-target="casInput" data-step="10" data-min="0" data-max="700">
                        <button type="button" class="spin-up">‚ñ≤</button>
                        <button type="button" class="spin-down">‚ñº</button>
                    </div>
                    <input id="casInput" type="number" step="1" value="350" class="field">
                    <span class="unit">kts</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Mach Number:</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="machInput" data-step="0.01" data-min="0" data-max="2">
                        <button type="button" class="spin-up">‚ñ≤</button>
                        <button type="button" class="spin-down">‚ñº</button>
                    </div>
                    <input id="machInput" type="number" step="0.01" value="0.80" class="field">
                    <span class="unit">M</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Altitude:</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="altInput" data-step="1000" data-min="0" data-max="50000">
                        <button type="button" class="spin-up">‚ñ≤</button>
                        <button type="button" class="spin-down">‚ñº</button>
                    </div>
                    <input id="altInput" type="number" step="100" value="23000" class="field">
                    <span class="unit">ft</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">ISA deviation (ŒîISA):</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="isaInput" data-step="1" data-min="-20" data-max="20">
                        <button type="button" class="spin-up">‚ñ≤</button>
                        <button type="button" class="spin-down">‚ñº</button>
                    </div>
                    <input id="isaInput" type="text" value="ISA+0" class="field">
                    <span class="unit">¬∞C</span>
                </div>
            </div>
        </div>

        <div class="card-footer">
            <button id="solveButton" class="primary-btn">
                <span class="icon">üßÆ</span>
                <span>◊ë◊®◊©◊ï◊™◊ö, ◊û◊û◊®◊ô◊ê ◊ë◊ú◊ô ◊ê◊ô◊©◊ï◊®</span>
            </button>

            <button id="resetButton" class="reset-btn">Reset</button>

        </div>

        <div id="calcResult" class="result-box">
            Result will appear here‚Ä¶
        </div>
    </div>

    <!-- Graph -->
    <div id="container">
        <canvas id="machCanvas"></canvas>
    </div>
    <!-- <div id="info">Move mouse or finger near a Mach line‚Ä¶</div>
    <div id="legend">
        Range: CAS 150‚Äì700 kt, Alt 0‚Äì40,000 ft. Graph always uses full horizontal range, phone-friendly.
    </div>
    <div id="isaControl">
        ŒîISA (¬∞C):
        <span id="isaValue">+0¬∞C</span>
        <input type="range" id="isaSlider" min="-20" max="20" value="0">
    </div> -->

    <script>
        // ===== ISA constants =====
        const T0   = 288.15;
        const P0   = 101325.0;
        const R    = 287.05287;
        const G    = 9.80665;
        const L    = 0.0065;
        const GAMMA = 1.4;
        const FT_PER_M = 3.28084;

        const CAS_MIN = 150;
        const CAS_MAX = 700;
        const ALT_MIN = 0;
        const ALT_MAX = 40000;

        const machValues = [];
        for (let m = 0.6; m <= 1.2001; m += 0.1) {
            machValues.push(parseFloat(m.toFixed(1)));
        }

        const altStepFt = 2000;

        const canvas = document.getElementById('machCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const isaSlider = document.getElementById('isaSlider');
        const isaValueSpan = document.getElementById('isaValue');

        const marginLeft = 70;
        const marginRight = 25;
        const marginTop = 40;
        const marginBottom = 50;

        let machLinesData = [];
        let lockedPoint = null;
        let currentPoint = null;
        let highlightCasTick = null;
        let highlightAltTick = null;
        let isaDeviationC = 0;
        let lastTouchPos = null;

        let viewCasMin = CAS_MIN;
        let viewCasMax = CAS_MAX;

        let calcMode = "solveAlt";

        // ===== helpers for ISA text =====
        function setIsaFieldFromValue(val) {
            const input = document.getElementById('isaInput');
            const sign = val >= 0 ? "+" : "";
            input.value = `ISA${sign}${val}`;
        }

        function parseIsaInput(str) {
            if (!str) return 0;
            let s = String(str).trim().toUpperCase();
            s = s.replace(/^ISA/, "");   // remove "ISA" if present
            s = s.trim();
            if (s === "") return 0;
            // keep + / - ; e.g. "+5", "-3", "0"
            const v = parseFloat(s);
            if (isNaN(v)) return NaN;
            return v;
        }

        // ===== ISA & CAS/Mach =====
        function isaAtAltitude(hMeters) {
            let T, p;
            if (hMeters <= 11000.0) {
                T = T0 - L * hMeters;
                p = P0 * Math.pow(T / T0, G / (R * L));
            } else {
                const T11 = T0 - L * 11000.0;
                const p11 = P0 * Math.pow(T11 / T0, G / (R * L));
                T = T11;
                p = p11 * Math.exp(-G * (hMeters - 11000.0) / (R * T));
            }
            const rho = p / (R * T);
            const a = Math.sqrt(GAMMA * R * T);
            return { T, p, rho, a };
        }

        function casFromMachAndAlt(M, hMeters) {
            const atm = isaAtAltitude(hMeters);
            const p = atm.p;
            const qc = p * (Math.pow(1 + 0.2 * M * M, 3.5) - 1.0);
            const a0 = Math.sqrt(GAMMA * R * T0);
            const ptOverP0 = qc / P0 + 1.0;
            const Vc2 = 5 * a0 * a0 * (Math.pow(ptOverP0, 2.0 / 7.0) - 1.0);
            const Vc2pos = Math.max(Vc2, 0);
            const Vc = Math.sqrt(Vc2pos);
            return Vc / 0.514444;
        }

        function tasFromPoint(point) {
            if (!point) return null;
            const altM = point.altFt / FT_PER_M;
            const atmISA = isaAtAltitude(altM);
            const T_actual = atmISA.T + isaDeviationC;
            const a_actual = Math.sqrt(GAMMA * R * T_actual);
            const tas_ms = point.M * a_actual;
            const tas_kt = tas_ms / 0.514444;
            return tas_kt;
        }

        function findAltitudeForCasAndMach(M, casTarget) {
            const hMin = ALT_MIN / FT_PER_M;
            const hMax = ALT_MAX / FT_PER_M;

            function f(h) {
                return casFromMachAndAlt(M, h) - casTarget;
            }

            let fMin = f(hMin);
            let fMax = f(hMax);
            if (!isFinite(fMin) || !isFinite(fMax) || fMin * fMax > 0) {
                return null;
            }

            let lo = hMin;
            let hi = hMax;
            for (let i = 0; i < 50; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fMin * fMid <= 0) {
                    hi = mid;
                    fMax = fMid;
                } else {
                    lo = mid;
                    fMin = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        function solveMachGivenCasAlt(casTarget, altFt) {
            const altM = altFt / FT_PER_M;
            function f(M) {
                return casFromMachAndAlt(M, altM) - casTarget;
            }

            let lo = 0.1;
            let hi = 2.0;
            let fLo = f(lo);
            let fHi = f(hi);

            if (!isFinite(fLo) || !isFinite(fHi) || fLo * fHi > 0) {
                return null;
            }

            for (let i = 0; i < 60; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fLo * fMid <= 0) {
                    hi = mid;
                    fHi = fMid;
                } else {
                    lo = mid;
                    fLo = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        // ===== mapping =====
        function xFromCas(cas) {
            const frac = (cas - viewCasMin) / (viewCasMax - viewCasMin);
            return marginLeft + frac * (canvas.width - marginLeft - marginRight);
        }

        function yFromAlt(altFt) {
            const frac = (altFt - ALT_MIN) / (ALT_MAX - ALT_MIN);
            return canvas.height - marginBottom - frac * (canvas.height - marginTop - marginBottom);
        }

        function casFromX(x) {
            const frac = (x - marginLeft) / (canvas.width - marginLeft - marginRight);
            return viewCasMin + frac * (viewCasMax - viewCasMin);
        }

        function altFromY(y) {
            const frac = (canvas.height - marginBottom - y) / (canvas.height - marginTop - marginBottom);
            return ALT_MIN + frac * (ALT_MAX - ALT_MIN);
        }

        function buildMachLineData(M) {
            const pts = [];
            for (let altFt = ALT_MIN; altFt <= ALT_MAX + 1; altFt += altStepFt) {
                const altM = altFt / FT_PER_M;
                const cas = casFromMachAndAlt(M, altM);
                pts.push({ cas, altFt });
            }
            return { M, pts };
        }

        function buildData() {
            machLinesData = [];
            for (const M of machValues) {
                machLinesData.push(buildMachLineData(M));
            }
        }

        function addMachLineIfMissing(M) {
            const mNum = Number(M);
            if (!isFinite(mNum)) return;
            const eps = 1e-6;
            for (const line of machLinesData) {
                if (Math.abs(line.M - mNum) < eps) return;
            }
            machLinesData.push(buildMachLineData(mNum));
        }

        // ===== axes & grid =====
        function drawAxesAndGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#020617";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // vertical grid
            ctx.strokeStyle = "#1f2937";
            ctx.lineWidth = 0.9;
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                const x = xFromCas(cas);
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
            }
            ctx.stroke();

            // horizontal grid
            ctx.beginPath();
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // axes
            ctx.strokeStyle = "#9ca3af";
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMax), yFromAlt(ALT_MIN));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMin), yFromAlt(ALT_MAX));
            ctx.stroke();

            // X ticks
            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const yAxis = yFromAlt(ALT_MIN);
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 10) {
                const x = xFromCas(cas);
                const tickLen = (cas % 50 === 0) ? 6 : 3;
                ctx.moveTo(x, yAxis);
                ctx.lineTo(x, yAxis + tickLen);
            }
            ctx.stroke();

            ctx.font = "11px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                const x = xFromCas(cas);
                const yAxisLocal = yFromAlt(ALT_MIN);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(x, yAxisLocal);
                ctx.lineTo(x, yAxisLocal + 6);
                ctx.stroke();

                if (highlightCasTick !== null && cas === highlightCasTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(cas.toString(), x, yAxisLocal + 8);
            }

            // Y ticks
            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const xAxis = xFromCas(viewCasMin);
            for (let alt = 0; alt <= 40000; alt += 1000) {
                const y = yFromAlt(alt);
                const tickLen = (alt % 5000 === 0) ? 6 : 3;
                ctx.moveTo(xAxis - tickLen, y);
                ctx.lineTo(xAxis, y);
            }
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                const xAxisLocal = xFromCas(viewCasMin);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(xAxisLocal - 6, y);
                ctx.lineTo(xAxisLocal, y);
                ctx.stroke();

                if (highlightAltTick !== null && alt === highlightAltTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(alt.toString(), xAxisLocal - 8, y);
            }

            ctx.fillStyle = "#e5e7eb";
            ctx.font = "13px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("CAS [kt]", (xFromCas(viewCasMin) + xFromCas(viewCasMax)) / 2, canvas.height - marginBottom + 20);

            ctx.save();
            ctx.translate(20, (yFromAlt(ALT_MIN) + yFromAlt(ALT_MAX)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("Altitude [ft]", 0, 0);
            ctx.restore();

            ctx.font = "16px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("Mach‚ÄìCAS‚ÄìAltitude Chart", canvas.width / 2, 8);
        }

        function drawMachLines(highlightMach) {
            const colors = ["#4FC3F7","#29B6F6","#03A9F4","#0288D1","#0277BD","#0ea5e9","#81D4FA"];
            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const pts = line.pts;
                const color = colors[i % colors.length];

                ctx.beginPath();
                let started = false;
                for (let j = 0; j < pts.length; j++) {
                    const cas = pts[j].cas;
                    if (cas < viewCasMin || cas > viewCasMax) continue;
                    const x = xFromCas(cas);
                    const y = yFromAlt(pts[j].altFt);
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                if (!started) continue;

                if (highlightMach != null && Math.abs(line.M - highlightMach) < 1e-6) {
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 2.0;
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.4;
                }
                ctx.stroke();
            }

            const labelAltFt = 36000;
            ctx.font = "11px system-ui";
            ctx.fillStyle = "#bfdbfe";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";

            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const casLabel = casFromMachAndAlt(line.M, labelAltFt / FT_PER_M);
                const xLabel = xFromCas(casLabel);
                const yLabel = yFromAlt(labelAltFt) - 8;

                ctx.save();
                ctx.translate(xLabel, yLabel);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(line.M.toFixed(2) + "M", 0, 0);
                ctx.restore();
            }
        }

        function drawPointLabel(point) {
            if (!point) return;

            const M   = Number(point.M);
            const cas = Number(point.cas);
            const alt = Number(point.altFt);
            if (!isFinite(M) || !isFinite(cas) || !isFinite(alt)) return;

            const x = xFromCas(cas);
            const y = yFromAlt(alt);

            const tas = tasFromPoint({ M: M, altFt: alt });
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";

            const text = `${M.toFixed(2)}M | ${cas.toFixed(1)} kt CAS | ${alt.toFixed(0)} ft | ${tasStr} kt TAS | ISA${deltaStr}`;

            ctx.font = "12px system-ui";
            const paddingX = 7;
            const paddingY = 5;
            const textWidth = ctx.measureText(text).width;

            let boxX = x + 10;
            let boxY = y - 12;

            if (boxX + textWidth + 2 * paddingX > canvas.width - marginRight) {
                boxX = x - 10 - (textWidth + 2 * paddingX);
            }

            ctx.fillStyle = "rgba(15,23,42,0.95)";
            ctx.strokeStyle = "#38bdf8";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(boxX, boxY - paddingY, textWidth + 2 * paddingX, 2 * paddingY + 14);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#E1F5FE";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText(text, boxX + paddingX, boxY - paddingY + 3);
        }

        function redraw(point) {
            currentPoint = point || null;
            drawAxesAndGrid();
            drawMachLines(point ? point.M : (lockedPoint ? lockedPoint.M : null));

            const p = point || lockedPoint;
            if (p) {
                const x = xFromCas(p.cas);
                const y = yFromAlt(p.altFt);

                ctx.strokeStyle = "#6b7280";
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = lockedPoint ? "#f97373" : "#facc15";
                ctx.beginPath();
                ctx.arc(x, y, 4.5, 0, 2 * Math.PI);
                ctx.fill();

                drawPointLabel(p);
            }
        }

        function findNearestOnLines(mx, my) {
            const thresholdPx = 12;

            let bestLine = null;
            let bestDist = Infinity;
            for (const line of machLinesData) {
                for (const pt of line.pts) {
                    const cas = pt.cas;
                    const px = xFromCas(cas);
                    const py = yFromAlt(pt.altFt);
                    const dx = px - mx;
                    const dy = py - my;
                    const d2 = dx*dx + dy*dy;
                    if (d2 < bestDist) {
                        bestDist = d2;
                        bestLine = line;
                    }
                }
            }

            if (!bestLine || Math.sqrt(bestDist) > thresholdPx) return null;

            let rawCas = casFromX(mx);
            let snappedCas = Math.round(rawCas / 10) * 10;
            if (snappedCas < CAS_MIN) snappedCas = CAS_MIN;
            if (snappedCas > CAS_MAX) snappedCas = CAS_MAX;

            const hM = findAltitudeForCasAndMach(bestLine.M, snappedCas);
            if (hM === null) return null;
            const altFt = hM * FT_PER_M;

            return { M: bestLine.M, cas: snappedCas, altFt: altFt };
        }

        function handlePointerMove(mx, my) {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
                infoDiv.textContent =
                    `LOCKED ‚Üí Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
                return;
            }

            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "Move mouse or finger near a Mach line‚Ä¶";
                return;
            }

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                highlightCasTick = Math.round(nearest.cas / 50) * 50;
                highlightAltTick = Math.round(nearest.altFt / 5000) * 5000;
                redraw(nearest);
                const tas = tasFromPoint(nearest);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
                infoDiv.textContent =
                    `Mach ${nearest.M.toFixed(2)} | CAS ${nearest.cas.toFixed(1)} kt | Alt ${nearest.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                const casApprox = casFromX(mx).toFixed(0);
                const altApprox = altFromY(my).toFixed(0);
                infoDiv.textContent =
                    `Not on a Mach line. Approx: CAS ‚âà ${casApprox} kt, Alt ‚âà ${altApprox} ft`;
            }
        }

        function handlePointerClick(mx, my) {
            if (lockedPoint) {
                lockedPoint = null;
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "Lock released. Move mouse or finger near a Mach line‚Ä¶";
                return;
            }

            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) return;

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                lockedPoint = nearest;
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
                infoDiv.textContent =
                    `LOCKED ‚Üí Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerMove(mx, my);
        });

        canvas.addEventListener('mouseleave', () => {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
                infoDiv.textContent =
                    `LOCKED ‚Üí Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "Move mouse or finger near a Mach line‚Ä¶";
            }
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerClick(mx, my);
        });

        canvas.addEventListener('touchstart', (e) => {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;
            lastTouchPos = { x: mx, y: my };
            handlePointerMove(mx, my);
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;
            lastTouchPos = { x: mx, y: my };
            handlePointerMove(mx, my);
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            if (lastTouchPos) {
                handlePointerClick(lastTouchPos.x, lastTouchPos.y);
                lastTouchPos = null;
            }
        });

        // API
        window.highlightMachCasAlt = function(M, cas, altFt) {
            const mNum   = Number(M);
            const casNum = Number(cas);

            if (!isFinite(mNum) || !isFinite(casNum)) {
                console.warn("highlightMachCasAlt: bad Mach/CAS", M, cas);
                return;
            }

            addMachLineIfMissing(mNum);

            let useAltFt = altFt;
            if (!isFinite(useAltFt)) {
                const hM = findAltitudeForCasAndMach(mNum, casNum);
                if (hM === null) {
                    console.warn("highlightMachCasAlt: no altitude solution", mNum, casNum);
                    return;
                }
                useAltFt = hM * FT_PER_M;
            }

            const altNum = Number(useAltFt);
            if (!isFinite(altNum)) {
                console.warn("highlightMachCasAlt: bad altitude", useAltFt);
                return;
            }

            lockedPoint = { M: mNum, cas: casNum, altFt: altNum };
            highlightCasTick = Math.round(casNum / 50) * 50;
            highlightAltTick = Math.round(altNum / 5000) * 5000;
            redraw(lockedPoint);

            const tas = tasFromPoint(lockedPoint);
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
            infoDiv.textContent =
                `LOCKED (API) ‚Üí Mach ${mNum.toFixed(2)} | CAS ${casNum.toFixed(1)} kt | Alt ${altNum.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
        };

        // panel calc
        function runAeroCalcFromPanel() {
            let M   = parseFloat(document.getElementById('machInput').value);
            let cas = parseFloat(document.getElementById('casInput').value);
            let alt = parseFloat(document.getElementById('altInput').value);
            let dIsa = parseIsaInput(document.getElementById('isaInput').value);

            if (isNaN(dIsa)) dIsa = 0;
            isaDeviationC = dIsa;
            const sign = dIsa >= 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${dIsa}¬∞C`;
            setIsaFieldFromValue(dIsa);
            isaSlider.value = dIsa;

            let solvedM = M;
            let solvedCas = cas;
            let solvedAlt = alt;

            if (calcMode === "solveMach") {
                if (!isFinite(cas) || !isFinite(alt)) {
                    alert("Mach mode: please enter CAS and Alt");
                    return;
                }
                const mRes = solveMachGivenCasAlt(cas, alt);
                if (mRes === null) {
                    alert("No Mach solution for this combination");
                    return;
                }
                solvedM = mRes;
                solvedCas = cas;
                solvedAlt = alt;
                document.getElementById('machInput').value = solvedM.toFixed(3);
            } else if (calcMode === "solveCas") {
                if (!isFinite(M) || !isFinite(alt)) {
                    alert("CAS mode: please enter Mach and Alt");
                    return;
                }
                const altM = alt / FT_PER_M;
                const casRes = casFromMachAndAlt(M, altM);
                solvedM = M;
                solvedCas = casRes;
                solvedAlt = alt;
                document.getElementById('casInput').value = solvedCas.toFixed(1);
            } else { // solveAlt
                if (!isFinite(M) || !isFinite(cas)) {
                    alert("Alt mode: please enter Mach and CAS");
                    return;
                }
                const hM = findAltitudeForCasAndMach(M, cas);
                if (hM === null) {
                    alert("No altitude solution for this combination");
                    return;
                }
                solvedM = M;
                solvedCas = cas;
                solvedAlt = hM * FT_PER_M;
                document.getElementById('altInput').value = solvedAlt.toFixed(0);
            }

            if (!isFinite(solvedM) || !isFinite(solvedCas) || !isFinite(solvedAlt)) {
                alert("Invalid solution");
                return;
            }

            const pointForTas = { M: solvedM, altFt: solvedAlt };
            const tasVal = tasFromPoint(pointForTas);
            const tasStr = tasVal ? tasVal.toFixed(1) : "N/A";
            const dIsaStr = (dIsa >= 0 ? "+" : "") + dIsa.toFixed(0) + "¬∞C";

            const resDiv = document.getElementById('calcResult');
            resDiv.innerHTML =
                `Mach: <b>${solvedM.toFixed(3)}</b> | ` +
                `CAS: <b>${solvedCas.toFixed(1)} kt</b> | ` +
                `Alt: <b>${solvedAlt.toFixed(0)} ft</b> | ` +
                `TAS: <b>${tasStr} kt</b> | ` +
                `ISA: <b>${dIsaStr}</b>`;

            addMachLineIfMissing(solvedM);
            window.highlightMachCasAlt(solvedM, solvedCas, solvedAlt);
        }

        function setCalcMode(mode) {
            calcMode = mode;

            const tabCas  = document.getElementById('tabCas');
            const tabMach = document.getElementById('tabMach');
            const tabAlt  = document.getElementById('tabAlt');

            tabCas.classList.remove('active');
            tabMach.classList.remove('active');
            tabAlt.classList.remove('active');

            const casInput  = document.getElementById('casInput');
            const machInput = document.getElementById('machInput');
            const altInput  = document.getElementById('altInput');

            casInput.disabled  = false;
            machInput.disabled = false;
            altInput.disabled  = false;

            if (mode === "solveCas") {
                tabCas.classList.add('active');
                casInput.disabled = true;
            } else if (mode === "solveMach") {
                tabMach.classList.add('active');
                machInput.disabled = true;
            } else {
                tabAlt.classList.add('active');
                altInput.disabled = true;
            }
        }

        function resetAll() {
            document.getElementById('casInput').value = 350;
            document.getElementById('machInput').value = 0.80;
            document.getElementById('altInput').value = 23000;
            isaDeviationC = 0;
            setIsaFieldFromValue(0);
            isaSlider.value = 0;
            isaValueSpan.textContent = "+0¬∞C";
            lockedPoint = null;
            currentPoint = null;
            highlightCasTick = null;
            highlightAltTick = null;
            document.getElementById('calcResult').textContent = "Result will appear here‚Ä¶";
            redraw(null);
            infoDiv.textContent = "Move mouse or finger near a Mach line‚Ä¶";
            setCalcMode("solveAlt");
        }

        // canvas size ‚Äì vertical layout
        function resizeCanvas() {
            const container = document.getElementById('container');
            const maxWidth = 600;
            const deviceWidth = container.clientWidth || window.innerWidth - 32;
            const width = Math.min(maxWidth, deviceWidth);
            const height = width * 1.2;
            canvas.width = width;
            canvas.height = height;
            redraw(currentPoint || lockedPoint || null);
        }

        window.addEventListener('resize', resizeCanvas);

        // spin buttons (including ISA special formatting)
        function attachSpinButtons() {
            document.querySelectorAll('.spin-buttons').forEach(spin => {
                const targetId = spin.dataset.target;
                const step = parseFloat(spin.dataset.step) || 1;
                const min = spin.dataset.min !== undefined ? parseFloat(spin.dataset.min) : null;
                const max = spin.dataset.max !== undefined ? parseFloat(spin.dataset.max) : null;
                const input = document.getElementById(targetId);
                if (!input) return;

                const isIsaField = (targetId === 'isaInput');

                function getVal() {
                    if (isIsaField) {
                        const v = parseIsaInput(input.value);
                        return isNaN(v) ? 0 : v;
                    } else {
                        let v = parseFloat(input.value);
                        if (isNaN(v)) v = 0;
                        return v;
                    }
                }

                function setVal(v) {
                    if (min !== null && v < min) v = min;
                    if (max !== null && v > max) v = max;

                    if (isIsaField) {
                        isaDeviationC = v;
                        setIsaFieldFromValue(v);
                        isaSlider.value = v;
                        const sign = v >= 0 ? "+" : "";
                        isaValueSpan.textContent = `${sign}${v}¬∞C`;
                    } else {
                        input.value = step >= 1 ? v.toFixed(0) : v.toFixed(2);
                    }
                }

                function adjust(sign) {
                    let v = getVal();
                    v += sign * step;
                    setVal(v);
                }

                const up = spin.querySelector('.spin-up');
                const down = spin.querySelector('.spin-down');
                if (up)   up.addEventListener('click', () => adjust(+1));
                if (down) down.addEventListener('click', () => adjust(-1));
            });
        }

        isaSlider.addEventListener('input', () => {
            isaDeviationC = parseInt(isaSlider.value, 10) || 0;
            const sign = isaDeviationC >= 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${isaDeviationC}¬∞C`;
            setIsaFieldFromValue(isaDeviationC);

            if (currentPoint || lockedPoint) {
                redraw(currentPoint || lockedPoint);
                const p = lockedPoint || currentPoint;
                const tas = tasFromPoint(p);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "¬∞C";
                infoDiv.textContent =
                    `${lockedPoint ? "LOCKED ‚Üí " : ""}Mach ${p.M.toFixed(2)} | CAS ${p.cas.toFixed(1)} kt | Alt ${p.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                redraw(null);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('solveButton').addEventListener('click', runAeroCalcFromPanel);
            document.getElementById('resetButton').addEventListener('click', resetAll);

            document.getElementById('tabCas').addEventListener('click', () => setCalcMode("solveCas"));
            document.getElementById('tabMach').addEventListener('click', () => setCalcMode("solveMach"));
            document.getElementById('tabAlt').addEventListener('click', () => setCalcMode("solveAlt"));

            setCalcMode("solveAlt");
            attachSpinButtons();
            resizeCanvas();
            setIsaFieldFromValue(0);
        });

        buildData();
    </script>
</body>
</html>
