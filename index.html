<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="UTF-8">
    <title>Aeronautical Calculator – Mach · CAS · Altitude</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg-main: #05070c;
            --bg-card: #0d141f;
            --bg-card-elevated: #111827;
            --bg-input: #111827;
            --bg-input-focus: #020617;
            --border-subtle: #1f2933;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.16);
            --accent-strong: #0ea5e9;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --danger: #f97373;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 16px;
            background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 60%, #000 100%);
            color: var(--text-main);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* הסרת החיצים של input type=number בדפדפנים */
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
        }

        h1 {
            font-size: 1.5rem;
            margin: 8px 0 4px;
            text-align: left;
            width: 100%;
            max-width: 960px;
        }

        .subtitle {
            width: 100%;
            max-width: 960px;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 10px;
            text-align: left;
        }

        .card {
            width: 100%;
            max-width: 960px;
            background: radial-gradient(circle at top left, #111827 0, #020617 65%);
            border-radius: 18px;
            border: 1px solid #111827;
            box-shadow:
                0 18px 40px rgba(15, 23, 42, 0.8),
                0 0 0 1px rgba(15, 23, 42, 0.9);
            padding: 18px 20px 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-header {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }

        .title-block {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .icon-circle {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            background: radial-gradient(circle at 20% 0, #38bdf8, #0f172a 70%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.4rem;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
        }

        .title-main {
            font-size: 1.15rem;
            font-weight: 600;
        }

        .title-sub {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .solve-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: center;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 4px;
        }

        .tab {
            flex: 1;
            padding: 10px 8px 8px;
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
            background: #020617;
            color: var(--text-muted);
            font-size: 0.8rem;
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 3px;
            transition: background 0.15s, border-color 0.15s, color 0.15s, box-shadow 0.15s;
        }

        .tab span:first-child {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .tab span:last-child {
            font-size: 0.7rem;
            text-transform: lowercase;
        }

        .tab.active {
            border-color: var(--accent);
            background: radial-gradient(circle at top, #0b1120 0, #020617 55%);
            color: var(--text-main);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
        }

        .form-rows {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 6px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 260px minmax(0, 1fr);
            gap: 12px;
            align-items: center;
        }

        .form-label {
            font-size: 0.95rem;
            color: var(--text-muted);
            text-align: center;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            width: 100%;
        }

        .field {
            flex: 1;
            width: auto;
            height: 52px;
            padding: 7px 10px;
            border-radius: 10px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-input);
            color: var(--text-main);
            font-size: 0.9rem;
            outline: none;
            text-align: right;
            transition: border-color 0.15s, background 0.15s, box-shadow 0.15s;
        }

        .field:focus {
            border-color: var(--accent);
            background: var(--bg-input-focus);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
        }

        .field:disabled {
            opacity: 0.55;
            cursor: default;
        }

        .unit {
            font-size: 0.95rem;
            color: var(--text-muted);
            min-width: 36px;
            text-align: center;
        }

        .spin-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            height: 52px;
        }

        .spin-buttons button {
            flex: 1;
            width: 32px;
            border-radius: 6px;
            border: 1px solid #374151;
            background: #020617;
            color: #e5e7eb;
            font-size: 0.85rem;
            padding: 0;
            cursor: pointer;
        }

        .spin-buttons button:hover {
            border-color: #4b5563;
            background: #030712;
        }

        .primary-btn {
            border: none;
            border-radius: 999px;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            color: #020617;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 26px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            box-shadow:
                0 12px 30px rgba(56, 189, 248, 0.5),
                0 0 0 1px rgba(15, 23, 42, 0.9);
        }

        .primary-btn span.icon {
            font-size: 1rem;
        }

        .primary-btn:disabled {
            background: #030712;
            color: #6b7280;
            box-shadow: none;
            cursor: default;
            opacity: 0.9;
        }

        .action-wrapper {
            justify-content: center;
        }

        .result-box {
            margin-top: 8px;
            font-size: 0.82rem;
            background: #020617;
            border-radius: 10px;
            padding: 6px 8px;
            border: 1px solid #111827;
            color: var(--text-main);
            text-align: center;
        }

        .result-box b {
            color: var(--accent-strong);
        }

        #container {
            margin-top: 18px;
            width: 100%;
            max-width: 600px;
        }

        #machCanvas {
            border-radius: 10px;
            border: 1px solid #111827;
            background: #020617;
            width: 100%;
            height: auto;
            display: block;
        }

        #info {
            margin-top: 8px;
            font-size: 0.9rem;
            text-align: center;
            min-height: 1.2em;
        }

        #legend {
            margin-top: 4px;
            font-size: 0.8rem;
            opacity: 0.8;
            text-align: center;
        }

        #isaControl {
            margin-top: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #isaControl span {
            min-width: 40px;
            display: inline-block;
            text-align: left;
        }

        input[type="range"] {
            width: 220px;
        }

        @media (max-width: 720px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .solve-label {
                text-align: right;
            }
        }
    </style>
</head>

<body>
    <h1>Aeronautical Calculator</h1>
    <div class="subtitle">CAS · Mach · Altitude – מחשבון אווירי + גרף אינטראקטיבי</div>

    <div class="card">
        <div class="card-header">
            <div class="title-block">
                <div class="icon-circle">✈️</div>
                <div>
                    <div class="title-main">Aeronautical Calculator</div>
                    <div class="title-sub">CAS · Mach · Altitude · TAS · ΔISA</div>
                </div>
            </div>

            <div class="solve-label" dir="rtl">בחר פרמטר לחישוב, פרינצי:</div>
        </div>

        <div class="tabs">
            <button class="tab" id="tabCas">
                <span>CAS</span><span>knots</span>
            </button>
            <button class="tab" id="tabMach">
                <span>MACH</span><span>number</span>
            </button>
            <button class="tab active" id="tabAlt">
                <span>ALT</span><span>feet</span>
            </button>
        </div>

        <div class="form-rows">
            <div class="form-row">
                <div class="form-label">Calibrated Airspeed (CAS):</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="casInput" data-step="10" data-min="0" data-max="700">
                        <button type="button" class="spin-up">▲</button>
                        <button type="button" class="spin-down">▼</button>
                    </div>
                    <input id="casInput" type="number" step="1" value="350" class="field">
                    <span class="unit">kts</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Mach Number:</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="machInput" data-step="0.01" data-min="0" data-max="2">
                        <button type="button" class="spin-up">▲</button>
                        <button type="button" class="spin-down">▼</button>
                    </div>
                    <input id="machInput" type="number" step="0.01" value="0.80" class="field">
                    <span class="unit">M</span>
                </div>
            </div>

            <div class="form-row">
                <div class="form-label">Altitude:</div>
                <div class="input-wrapper">
                    <div class="spin-buttons" data-target="altInput" data-step="1000" data-min="0" data-max="50000">
                        <button type="button" class="spin-up">▲</button>
                        <button type="button" class="spin-down">▼</button>
                    </div>
                    <input id="altInput" type="number" step="100" value="23000" class="field">
                    <span class="unit">ft</span>
                </div>
            </div>

            <div id="isaControl">
                ISA
                <span id="isaValue">+0°C</span>
                <input type="range" id="isaSlider" min="-20" max="20" value="0">
            </div>

            <div class="form-row action-row">
                <div class="form-label"></div>
                <div class="input-wrapper action-wrapper">
                    <button id="solveButton" class="primary-btn" disabled>
                        <span class="icon">✈️</span>
                        <span>ברשותך, ממריא בלי אישור</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="calcResult" class="result-box">
            Result will appear here…
        </div>
    </div>

    <div id="container">
        <canvas id="machCanvas"></canvas>
    </div>
    <div id="info">Move mouse or finger near a Mach line…</div>
    <div id="legend">
        Range: CAS 150–700 kt, Alt 0–40,000 ft. Graph always uses full horizontal range, phone-friendly.
    </div>

    <script>
        // ===== ISA constants =====
        const T0 = 288.15;
        const P0 = 101325.0;
        const R = 287.05287;
        const G = 9.80665;
        const L = 0.0065;
        const GAMMA = 1.4;
        const FT_PER_M = 3.28084;

        const CAS_MIN = 150;
        const CAS_MAX = 700;
        const ALT_MIN = 0;
        const ALT_MAX = 40000;

        const machValues = [];
        for (let m = 0.6; m <= 1.2001; m += 0.1) {
            machValues.push(parseFloat(m.toFixed(1)));
        }

        const altStepFt = 2000;

        const canvas = document.getElementById('machCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const isaSlider = document.getElementById('isaSlider');
        const isaValueSpan = document.getElementById('isaValue');
        const solveButton = document.getElementById('solveButton');

        const marginLeft = 70;
        const marginRight = 25;
        const marginTop = 40;
        const marginBottom = 50;

        let machLinesData = [];
        let lockedPoint = null;
        let currentPoint = null;
        let highlightCasTick = null;
        let highlightAltTick = null;
        let isaDeviationC = 0;
        let lastTouchPos = null;

        let viewCasMin = CAS_MIN;
        let viewCasMax = CAS_MAX;

        let isPinching = false;
        let pinchStartDist = 0;
        let pinchStartViewCasMin = CAS_MIN;
        let pinchStartViewCasMax = CAS_MAX;
        let dragLockedTouch = false;

        let calcMode = "solveAlt";
        let hasPendingChanges = false;

        function setSolveEnabled(enabled) {
            if (!solveButton) return;
            solveButton.disabled = !enabled;
        }

        function markChanged() {
            hasPendingChanges = true;
            setSolveEnabled(true);
        }

        function isaAtAltitude(hMeters) {
            let T, p;
            if (hMeters <= 11000.0) {
                T = T0 - L * hMeters;
                p = P0 * Math.pow(T / T0, G / (R * L));
            } else {
                const T11 = T0 - L * 11000.0;
                const p11 = P0 * Math.pow(T11 / T0, G / (R * L));
                T = T11;
                p = p11 * Math.exp(-G * (hMeters - 11000.0) / (R * T));
            }
            const rho = p / (R * T);
            const a = Math.sqrt(GAMMA * R * T);
            return { T, p, rho, a };
        }

        function casFromMachAndAlt(M, hMeters) {
            const atm = isaAtAltitude(hMeters);
            const p = atm.p;
            const qc = p * (Math.pow(1 + 0.2 * M * M, 3.5) - 1.0);
            const a0 = Math.sqrt(GAMMA * R * T0);
            const ptOverP0 = qc / P0 + 1.0;
            const Vc2 = 5 * a0 * a0 * (Math.pow(ptOverP0, 2.0 / 7.0) - 1.0);
            const Vc2pos = Math.max(Vc2, 0);
            const Vc = Math.sqrt(Vc2pos);
            return Vc / 0.514444;
        }

        function tasFromPoint(point) {
            if (!point) return null;
            const altM = point.altFt / FT_PER_M;
            const atmISA = isaAtAltitude(altM);
            const T_actual = atmISA.T + isaDeviationC;
            const a_actual = Math.sqrt(GAMMA * R * T_actual);
            const tas_ms = point.M * a_actual;
            const tas_kt = tas_ms / 0.514444;
            return tas_kt;
        }

        function findAltitudeForCasAndMach(M, casTarget) {
            const hMin = ALT_MIN / FT_PER_M;
            const hMax = ALT_MAX / FT_PER_M;

            function f(h) {
                return casFromMachAndAlt(M, h) - casTarget;
            }

            let fMin = f(hMin);
            let fMax = f(hMax);
            if (!isFinite(fMin) || !isFinite(fMax) || fMin * fMax > 0) {
                return null;
            }

            let lo = hMin;
            let hi = hMax;
            for (let i = 0; i < 50; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fMin * fMid <= 0) {
                    hi = mid;
                    fMax = fMid;
                } else {
                    lo = mid;
                    fMin = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        function solveMachGivenCasAlt(casTarget, altFt) {
            const altM = altFt / FT_PER_M;
            function f(M) {
                return casFromMachAndAlt(M, altM) - casTarget;
            }

            let lo = 0.1;
            let hi = 2.0;
            let fLo = f(lo);
            let fHi = f(hi);

            if (!isFinite(fLo) || !isFinite(fHi) || fLo * fHi > 0) {
                return null;
            }

            for (let i = 0; i < 60; i++) {
                const mid = 0.5 * (lo + hi);
                const fMid = f(mid);
                if (fLo * fMid <= 0) {
                    hi = mid;
                    fHi = fMid;
                } else {
                    lo = mid;
                    fLo = fMid;
                }
            }
            return 0.5 * (lo + hi);
        }

        function xFromCas(cas) {
            const frac = (cas - viewCasMin) / (viewCasMax - viewCasMin);
            return marginLeft + frac * (canvas.width - marginLeft - marginRight);
        }

        function yFromAlt(altFt) {
            const frac = (altFt - ALT_MIN) / (ALT_MAX - ALT_MIN);
            return canvas.height - marginBottom - frac * (canvas.height - marginTop - marginBottom);
        }

        function casFromX(x) {
            const frac = (x - marginLeft) / (canvas.width - marginLeft - marginRight);
            return viewCasMin + frac * (viewCasMax - viewCasMin);
        }

        function altFromY(y) {
            const frac = (canvas.height - marginBottom - y) / (canvas.height - marginTop - marginBottom);
            return ALT_MIN + frac * (ALT_MAX - ALT_MIN);
        }

        function buildMachLineData(M) {
            const pts = [];
            for (let altFt = ALT_MIN; altFt <= ALT_MAX + 1; altFt += altStepFt) {
                const altM = altFt / FT_PER_M;
                const cas = casFromMachAndAlt(M, altM);
                pts.push({ cas, altFt });
            }
            return { M, pts };
        }

        function addMachLineIfMissing(M) {
            const mNum = Number(M);
            if (!isFinite(mNum)) return;
            const eps = 1e-6;
            for (const line of machLinesData) {
                if (Math.abs(line.M - mNum) < eps) return;
            }
            machLinesData.push(buildMachLineData(mNum));
        }

        function drawAxesAndGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#020617";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "#1f2937";
            ctx.lineWidth = 0.9;
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                const x = xFromCas(cas);
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
            }
            ctx.stroke();

            ctx.beginPath();
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.strokeStyle = "#9ca3af";
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMax), yFromAlt(ALT_MIN));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(xFromCas(viewCasMin), yFromAlt(ALT_MIN));
            ctx.lineTo(xFromCas(viewCasMin), yFromAlt(ALT_MAX));
            ctx.stroke();

            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const yAxis = yFromAlt(ALT_MIN);
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 10) {
                const x = xFromCas(cas);
                const tickLen = (cas % 50 === 0) ? 6 : 3;
                ctx.moveTo(x, yAxis);
                ctx.lineTo(x, yAxis + tickLen);
            }
            ctx.stroke();

            ctx.font = "11px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let cas = CAS_MIN; cas <= CAS_MAX; cas += 50) {
                const x = xFromCas(cas);
                const yAxisLocal = yFromAlt(ALT_MIN);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(x, yAxisLocal);
                ctx.lineTo(x, yAxisLocal + 6);
                ctx.stroke();

                if (highlightCasTick !== null && cas === highlightCasTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(cas.toString(), x, yAxisLocal + 8);
            }

            ctx.strokeStyle = "#4b5563";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            const xAxis = xFromCas(viewCasMin);
            for (let alt = 0; alt <= 40000; alt += 1000) {
                const y = yFromAlt(alt);
                const tickLen = (alt % 5000 === 0) ? 6 : 3;
                ctx.moveTo(xAxis - tickLen, y);
                ctx.lineTo(xAxis, y);
            }
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (let alt = 0; alt <= 40000; alt += 5000) {
                const y = yFromAlt(alt);
                const xAxisLocal = xFromCas(viewCasMin);

                ctx.strokeStyle = "#9ca3af";
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                ctx.moveTo(xAxisLocal - 6, y);
                ctx.lineTo(xAxisLocal, y);
                ctx.stroke();

                if (highlightAltTick !== null && alt === highlightAltTick) {
                    ctx.fillStyle = "#38bdf8";
                    ctx.font = "bold 11px system-ui";
                } else {
                    ctx.fillStyle = "#e5e7eb";
                    ctx.font = "11px system-ui";
                }
                ctx.fillText(alt.toString(), xAxisLocal - 8, y);
            }

            ctx.fillStyle = "#e5e7eb";
            ctx.font = "13px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("CAS [kt]", (xFromCas(viewCasMin) + xFromCas(viewCasMax)) / 2, canvas.height - marginBottom + 20);

            ctx.save();
            ctx.translate(20, (yFromAlt(ALT_MIN) + yFromAlt(ALT_MAX)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("Altitude [ft]", 0, 0);
            ctx.restore();

            ctx.font = "16px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("Mach–CAS–Altitude Chart", canvas.width / 2, 8);
        }

        function drawMachLines(highlightMach) {
            const colors = ["#4FC3F7", "#29B6F6", "#03A9F4", "#0288D1", "#0277BD", "#0ea5e9", "#81D4FA"];
            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const pts = line.pts;
                const color = colors[i % colors.length];

                ctx.beginPath();
                let started = false;
                for (let j = 0; j < pts.length; j++) {
                    const cas = pts[j].cas;
                    if (cas < viewCasMin || cas > viewCasMax) continue;
                    const x = xFromCas(cas);
                    const y = yFromAlt(pts[j].altFt);
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                if (!started) continue;

                if (highlightMach != null && Math.abs(line.M - highlightMach) < 1e-6) {
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 2.0;
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.4;
                }
                ctx.stroke();
            }

            const labelAltFt = 36000;
            ctx.font = "11px system-ui";
            ctx.fillStyle = "#bfdbfe";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";

            for (let i = 0; i < machLinesData.length; i++) {
                const line = machLinesData[i];
                const casLabel = casFromMachAndAlt(line.M, labelAltFt / FT_PER_M);
                const xLabel = xFromCas(casLabel);
                const yLabel = yFromAlt(labelAltFt) - 8;

                ctx.save();
                ctx.translate(xLabel, yLabel);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(line.M.toFixed(2) + "M", 0, 0);
                ctx.restore();
            }
        }

        function drawPointLabel(point) {
            if (!point) return;

            const M = Number(point.M);
            const cas = Number(point.cas);
            const alt = Number(point.altFt);
            if (!isFinite(M) || !isFinite(cas) || !isFinite(alt)) return;

            const x = xFromCas(cas);
            const y = yFromAlt(alt);

            const tas = tasFromPoint({ M: M, altFt: alt });
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";

            const text = `${M.toFixed(2)}M | ${cas.toFixed(1)} kt CAS | ${alt.toFixed(0)} ft | ${tasStr} kt TAS | ISA${deltaStr}`;

            ctx.font = "12px system-ui";
            const paddingX = 7;
            const paddingY = 5;
            const textWidth = ctx.measureText(text).width;

            let boxX = x + 10;
            let boxY = y - 12;

            if (boxX + textWidth + 2 * paddingX > canvas.width - marginRight) {
                boxX = x - 10 - (textWidth + 2 * paddingX);
            }

            ctx.fillStyle = "rgba(15,23,42,0.95)";
            ctx.strokeStyle = "#38bdf8";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(boxX, boxY - paddingY, textWidth + 2 * paddingX, 2 * paddingY + 14);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#E1F5FE";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText(text, boxX + paddingX, boxY - paddingY + 3);
        }

        function redraw(point) {
            currentPoint = point || null;
            drawAxesAndGrid();
            drawMachLines(point ? point.M : (lockedPoint ? lockedPoint.M : null));

            const p = point || lockedPoint;
            if (p) {
                const x = xFromCas(p.cas);
                const y = yFromAlt(p.altFt);

                ctx.strokeStyle = "#6b7280";
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, yFromAlt(ALT_MIN));
                ctx.lineTo(x, yFromAlt(ALT_MAX));
                ctx.moveTo(xFromCas(viewCasMin), y);
                ctx.lineTo(xFromCas(viewCasMax), y);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = lockedPoint ? "#f97373" : "#facc15";
                ctx.beginPath();
                ctx.arc(x, y, 4.5, 0, 2 * Math.PI);
                ctx.fill();

                drawPointLabel(p);
            }
        }

        function findNearestOnLines(mx, my) {
            const thresholdPx = 12;

            let bestLine = null;
            let bestDist = Infinity;
            for (const line of machLinesData) {
                for (const pt of line.pts) {
                    const cas = pt.cas;
                    const px = xFromCas(cas);
                    const py = yFromAlt(pt.altFt);
                    const dx = px - mx;
                    const dy = py - my;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < bestDist) {
                        bestDist = d2;
                        bestLine = line;
                    }
                }
            }

            if (!bestLine || Math.sqrt(bestDist) > thresholdPx) return null;

            let rawCas = casFromX(mx);
            let snappedCas = Math.round(rawCas / 10) * 10;
            if (snappedCas < CAS_MIN) snappedCas = CAS_MIN;
            if (snappedCas > CAS_MAX) snappedCas = CAS_MAX;

            const hM = findAltitudeForCasAndMach(bestLine.M, snappedCas);
            if (hM === null) return null;
            const altFt = hM * FT_PER_M;

            return { M: bestLine.M, cas: snappedCas, altFt: altFt };
        }

        function updateLockedPointFromY(my) {
            if (!lockedPoint) return;
            let alt = altFromY(my);
            if (alt < ALT_MIN) alt = ALT_MIN;
            if (alt > ALT_MAX) alt = ALT_MAX;
            const altM = alt / FT_PER_M;
            const cas = casFromMachAndAlt(lockedPoint.M, altM);
            lockedPoint = { M: lockedPoint.M, cas: cas, altFt: alt };
            highlightCasTick = Math.round(cas / 50) * 50;
            highlightAltTick = Math.round(alt / 5000) * 5000;
            redraw(lockedPoint);
            const tas = tasFromPoint(lockedPoint);
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
            infoDiv.textContent =
                `LOCKED → Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
        }

        function handlePointerMove(mx, my) {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
                infoDiv.textContent =
                    `LOCKED → Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
                return;
            }

            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "Move mouse or finger near a Mach line…";
                return;
            }

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                highlightCasTick = Math.round(nearest.cas / 50) * 50;
                highlightAltTick = Math.round(nearest.altFt / 5000) * 5000;
                redraw(nearest);
                const tas = tasFromPoint(nearest);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
                infoDiv.textContent =
                    `Mach ${nearest.M.toFixed(2)} | CAS ${nearest.cas.toFixed(1)} kt | Alt ${nearest.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                const casApprox = casFromX(mx).toFixed(0);
                const altApprox = altFromY(my).toFixed(0);
                infoDiv.textContent =
                    `Not on a Mach line. Approx: CAS ≈ ${casApprox} kt, Alt ≈ ${altApprox} ft`;
            }
        }

        function handlePointerClick(mx, my) {
            if (mx < marginLeft || mx > canvas.width - marginRight ||
                my < marginTop || my > canvas.height - marginBottom) return;

            const nearest = findNearestOnLines(mx, my);
            if (nearest) {
                lockedPoint = nearest;
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
                infoDiv.textContent =
                    `LOCKED → Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerMove(mx, my);
        });

        canvas.addEventListener('mouseleave', () => {
            if (lockedPoint) {
                highlightCasTick = Math.round(lockedPoint.cas / 50) * 50;
                highlightAltTick = Math.round(lockedPoint.altFt / 5000) * 5000;
                redraw(lockedPoint);
                const tas = tasFromPoint(lockedPoint);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
                infoDiv.textContent =
                    `LOCKED → Mach ${lockedPoint.M.toFixed(2)} | CAS ${lockedPoint.cas.toFixed(1)} kt | Alt ${lockedPoint.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                highlightCasTick = null;
                highlightAltTick = null;
                redraw(null);
                infoDiv.textContent = "Move mouse or finger near a Mach line…";
            }
        });

        // Mouse wheel zoom (CAS axis)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
            const centerCas = casFromX(mx);
            const width = viewCasMax - viewCasMin;
            let newWidth = width * zoomFactor;
            newWidth = Math.max(50, Math.min(CAS_MAX - CAS_MIN, newWidth));
            let newMin = centerCas - newWidth / 2;
            let newMax = centerCas + newWidth / 2;
            if (newMin < CAS_MIN) {
                newMin = CAS_MIN;
                newMax = CAS_MIN + newWidth;
            }
            if (newMax > CAS_MAX) {
                newMax = CAS_MAX;
                newMin = CAS_MAX - newWidth;
            }
            viewCasMin = newMin;
            viewCasMax = newMax;
            redraw(currentPoint || lockedPoint || null);
        }, { passive: false });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            handlePointerClick(mx, my);
        });

        canvas.addEventListener('touchstart', (e) => {
            const rect = canvas.getBoundingClientRect();

            if (e.touches.length === 2) {
                // start pinch
                isPinching = true;
                dragLockedTouch = false;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dx = t2.clientX - t1.clientX;
                const dy = t2.clientY - t1.clientY;
                pinchStartDist = Math.hypot(dx, dy);
                pinchStartViewCasMin = viewCasMin;
                pinchStartViewCasMax = viewCasMax;
                return;
            }

            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const mx = touch.clientX - rect.left;
                const my = touch.clientY - rect.top;
                lastTouchPos = { x: mx, y: my };

                if (lockedPoint) {
                    // start dragging along Mach line
                    dragLockedTouch = true;
                    updateLockedPointFromY(my);
                } else {
                    dragLockedTouch = false;
                    handlePointerMove(mx, my);
                }
            }
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            const rect = canvas.getBoundingClientRect();

            if (e.touches.length === 2) {
                // pinch zoom
                e.preventDefault();
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dx = t2.clientX - t1.clientX;
                const dy = t2.clientY - t1.clientY;
                const dist = Math.hypot(dx, dy);
                if (pinchStartDist > 0) {
                    const factor = pinchStartDist / dist;
                    let width0 = pinchStartViewCasMax - pinchStartViewCasMin;
                    let newWidth = width0 * factor;
                    newWidth = Math.max(50, Math.min(CAS_MAX - CAS_MIN, newWidth));
                    const center = (pinchStartViewCasMin + pinchStartViewCasMax) / 2;
                    let newMin = center - newWidth / 2;
                    let newMax = center + newWidth / 2;
                    if (newMin < CAS_MIN) {
                        newMin = CAS_MIN;
                        newMax = CAS_MIN + newWidth;
                    }
                    if (newMax > CAS_MAX) {
                        newMax = CAS_MAX;
                        newMin = CAS_MAX - newWidth;
                    }
                    viewCasMin = newMin;
                    viewCasMax = newMax;
                    redraw(currentPoint || lockedPoint || null);
                }
                return;
            }

            if (e.touches.length === 1) {
                e.preventDefault();
                const touch = e.touches[0];
                const mx = touch.clientX - rect.left;
                const my = touch.clientY - rect.top;
                lastTouchPos = { x: mx, y: my };

                if (dragLockedTouch && lockedPoint) {
                    updateLockedPointFromY(my);
                } else {
                    handlePointerMove(mx, my);
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                isPinching = false;
            }
            if (e.touches.length === 0) {
                if (lastTouchPos && !dragLockedTouch) {
                    handlePointerClick(lastTouchPos.x, lastTouchPos.y);
                }
                lastTouchPos = null;
                dragLockedTouch = false;
            }
        });

        // API
        window.highlightMachCasAlt = function (M, cas, altFt) {
            const mNum = Number(M);
            const casNum = Number(cas);

            if (!isFinite(mNum) || !isFinite(casNum)) {
                console.warn("highlightMachCasAlt: bad Mach/CAS", M, cas);
                return;
            }

            addMachLineIfMissing(mNum);

            let useAltFt = altFt;
            if (!isFinite(useAltFt)) {
                const hM = findAltitudeForCasAndMach(mNum, casNum);
                if (hM === null) {
                    console.warn("highlightMachCasAlt: no altitude solution", mNum, casNum);
                    return;
                }
                useAltFt = hM * FT_PER_M;
            }

            const altNum = Number(useAltFt);
            if (!isFinite(altNum)) {
                console.warn("highlightMachCasAlt: bad altitude", useAltFt);
                return;
            }

            lockedPoint = { M: mNum, cas: casNum, altFt: altNum };
            highlightCasTick = Math.round(casNum / 50) * 50;
            highlightAltTick = Math.round(altNum / 5000) * 5000;
            redraw(lockedPoint);

            const tas = tasFromPoint(lockedPoint);
            const tasStr = tas ? tas.toFixed(1) : "N/A";
            const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
            infoDiv.textContent =
                `LOCKED (API) → Mach ${mNum.toFixed(2)} | CAS ${casNum.toFixed(1)} kt | Alt ${altNum.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
        };

        function runAeroCalcFromPanel() {
            let M = parseFloat(document.getElementById('machInput').value);
            let cas = parseFloat(document.getElementById('casInput').value);
            let alt = parseFloat(document.getElementById('altInput').value);
            let dIsa = parseInt(isaSlider.value, 10) || 0;

            if (isNaN(dIsa)) dIsa = 0;
            isaDeviationC = dIsa;
            const sign = dIsa >= 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${dIsa}°C`;
            isaSlider.value = dIsa;

            let solvedM = M;
            let solvedCas = cas;
            let solvedAlt = alt;

            if (calcMode === "solveMach") {
                if (!isFinite(cas) || !isFinite(alt)) {
                    alert("Mach mode: please enter CAS and Alt");
                    return;
                }
                const mRes = solveMachGivenCasAlt(cas, alt);
                if (mRes === null) {
                    alert("No Mach solution for this combination");
                    return;
                }
                solvedM = mRes;
                solvedCas = cas;
                solvedAlt = alt;
                document.getElementById('machInput').value = solvedM.toFixed(3);
            } else if (calcMode === "solveCas") {
                if (!isFinite(M) || !isFinite(alt)) {
                    alert("CAS mode: please enter Mach and Alt");
                    return;
                }
                const altM = alt / FT_PER_M;
                const casRes = casFromMachAndAlt(M, altM);
                solvedM = M;
                solvedCas = casRes;
                solvedAlt = alt;
                document.getElementById('casInput').value = solvedCas.toFixed(1);
            } else {
                if (!isFinite(M) || !isFinite(cas)) {
                    alert("Alt mode: please enter Mach and CAS");
                    return;
                }
                const hM = findAltitudeForCasAndMach(M, cas);
                if (hM === null) {
                    alert("No altitude solution for this combination");
                    return;
                }
                solvedM = M;
                solvedCas = cas;
                solvedAlt = hM * FT_PER_M;
                document.getElementById('altInput').value = solvedAlt.toFixed(0);
            }

            if (!isFinite(solvedM) || !isFinite(solvedCas) || !isFinite(solvedAlt)) {
                alert("Invalid solution");
                return;
            }

            const pointForTas = { M: solvedM, altFt: solvedAlt };
            const tasVal = tasFromPoint(pointForTas);
            const tasStr = tasVal ? tasVal.toFixed(1) : "N/A";
            const dIsaStr = (dIsa >= 0 ? "+" : "") + dIsa.toFixed(0) + "°C";

            const resDiv = document.getElementById('calcResult');
            resDiv.innerHTML =
                `Mach: <b>${solvedM.toFixed(3)}</b> | ` +
                `CAS: <b>${solvedCas.toFixed(1)} kt</b> | ` +
                `Alt: <b>${solvedAlt.toFixed(0)} ft</b> | ` +
                `TAS: <b>${tasStr} kt</b> | ` +
                `ISA: <b>${dIsaStr}</b>`;

            addMachLineIfMissing(solvedM);
            window.highlightMachCasAlt(solvedM, solvedCas, solvedAlt);

            hasPendingChanges = false;
            setSolveEnabled(false);
        }

        function setCalcMode(mode) {
            calcMode = mode;

            const tabCas = document.getElementById('tabCas');
            const tabMach = document.getElementById('tabMach');
            const tabAlt = document.getElementById('tabAlt');

            tabCas.classList.remove('active');
            tabMach.classList.remove('active');
            tabAlt.classList.remove('active');

            const casInput = document.getElementById('casInput');
            const machInput = document.getElementById('machInput');
            const altInput = document.getElementById('altInput');

            casInput.disabled = false;
            machInput.disabled = false;
            altInput.disabled = false;

            if (mode === "solveCas") {
                tabCas.classList.add('active');
                casInput.disabled = true;
            } else if (mode === "solveMach") {
                tabMach.classList.add('active');
                machInput.disabled = true;
            } else {
                tabAlt.classList.add('active');
                altInput.disabled = true;
            }

            markChanged();
        }

        function resizeCanvas() {
            const container = document.getElementById('container');
            const maxWidth = 600;
            const deviceWidth = container.clientWidth || window.innerWidth - 32;
            const width = Math.min(maxWidth, deviceWidth);
            const height = width * 1.2;
            canvas.width = width;
            canvas.height = height;
            redraw(currentPoint || lockedPoint || null);
        }

        window.addEventListener('resize', resizeCanvas);

        function attachSpinButtons() {
            document.querySelectorAll('.spin-buttons').forEach(spin => {
                const targetId = spin.dataset.target;
                const step = parseFloat(spin.dataset.step) || 1;
                const min = spin.dataset.min !== undefined ? parseFloat(spin.dataset.min) : null;
                const max = spin.dataset.max !== undefined ? parseFloat(spin.dataset.max) : null;
                const input = document.getElementById(targetId);
                if (!input) return;

                function getVal() {
                    let v = parseFloat(input.value);
                    if (isNaN(v)) v = 0;
                    return v;
                }

                function setVal(v) {
                    if (min !== null && v < min) v = min;
                    if (max !== null && v > max) v = max;
                    input.value = step >= 1 ? v.toFixed(0) : v.toFixed(2);
                    markChanged();
                }

                function adjust(sign) {
                    let v = getVal();
                    v += sign * step;
                    setVal(v);
                }

                const up = spin.querySelector('.spin-up');
                const down = spin.querySelector('.spin-down');
                if (up) up.addEventListener('click', () => adjust(+1));
                if (down) down.addEventListener('click', () => adjust(-1));
            });
        }

        isaSlider.addEventListener('input', () => {
            isaDeviationC = parseInt(isaSlider.value, 10) || 0;
            const sign = isaDeviationC >= 0 ? "+" : "";
            isaValueSpan.textContent = `${sign}${isaDeviationC}°C`;

            if (currentPoint || lockedPoint) {
                redraw(currentPoint || lockedPoint);
                const p = lockedPoint || currentPoint;
                const tas = tasFromPoint(p);
                const tasStr = tas ? tas.toFixed(1) : "N/A";
                const deltaStr = (isaDeviationC >= 0 ? "+" : "") + isaDeviationC.toFixed(0) + "°C";
                infoDiv.textContent =
                    `${lockedPoint ? "LOCKED → " : ""}Mach ${p.M.toFixed(2)} | CAS ${p.cas.toFixed(1)} kt | Alt ${p.altFt.toFixed(0)} ft | TAS ${tasStr} kt | ISA${deltaStr}`;
            } else {
                redraw(null);
            }

            markChanged();
        });

        document.addEventListener('DOMContentLoaded', () => {
            solveButton.addEventListener('click', runAeroCalcFromPanel);

            document.getElementById('tabCas').addEventListener('click', () => setCalcMode("solveCas"));
            document.getElementById('tabMach').addEventListener('click', () => setCalcMode("solveMach"));
            document.getElementById('tabAlt').addEventListener('click', () => setCalcMode("solveAlt"));

            document.getElementById('casInput').addEventListener('input', markChanged);
            document.getElementById('machInput').addEventListener('input', markChanged);
            document.getElementById('altInput').addEventListener('input', markChanged);

            setCalcMode("solveAlt");
            attachSpinButtons();
            resizeCanvas();
            setSolveEnabled(false);
        });

        function buildData() {
            machLinesData = [];
            for (const M of machValues) {
                machLinesData.push(buildMachLineData(M));
            }
        }

        buildData();
    </script>
</body>

</html>
